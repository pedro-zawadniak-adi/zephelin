From 2635e4b7e3c2240aeb24afd273f33208b9a70e80 Mon Sep 17 00:00:00 2001
From: Maciej Sobkowski <msobkowski@antmicro.com>
Date: Tue, 8 Jul 2025 16:36:13 +0200
Subject: [PATCH] instrumentation: make runtime configuration of
 trigger/stopper functions optional

This makes using instrumentation much easier with any sample/board
combination much easier, as it eliminates the need to define a custom
dt overlay. Trigger/stopper functions need to be configured at build time.

Signed-off-by: Maciej Sobkowski <msobkowski@antmicro.com>
---
 .../zephyr/instrumentation/instrumentation.h  |  6 +++++
 scripts/zaru.py                               | 20 ++++++++++++--
 subsys/instrumentation/Kconfig                | 26 ++++++++++++-------
 subsys/instrumentation/common/instr_common.c  | 17 ++++++++++++
 subsys/instrumentation/transport/uart.c       |  2 +-
 5 files changed, 59 insertions(+), 12 deletions(-)

diff --git a/include/zephyr/instrumentation/instrumentation.h b/include/zephyr/instrumentation/instrumentation.h
index f37d3d181b1..d4f21afc5c1 100644
--- a/include/zephyr/instrumentation/instrumentation.h
+++ b/include/zephyr/instrumentation/instrumentation.h
@@ -81,6 +81,12 @@ bool instr_tracing_supported(void);
  */
 bool instr_profiling_supported(void);
 
+/**
+ * @brief Checks if dynamic trigger configuration feature is available.
+ *
+ */
+bool instr_dynamic_trigger_supported(void);
+
 /**
  * @brief Checks if subsystem is ready to be initialized. Must called be before
  *        instr_init().
diff --git a/scripts/zaru.py b/scripts/zaru.py
index 0a76a886063..cea1d142856 100755
--- a/scripts/zaru.py
+++ b/scripts/zaru.py
@@ -31,7 +31,7 @@ from west.app.main import WestApp
 from west.configuration import Configuration, config
 from west.util import west_topdir
 
-STATUS_REPLY_PATTERN = r"(0|1)\s(0|1)"
+STATUS_REPLY_PATTERN = r"(0|1)\s(0|1)\s(0|1)"
 
 
 LISTSETS_REPLY_PATTERN = r"(trigger|stopper): (0x[0-9A-Fa-f]+)"
@@ -317,8 +317,13 @@ def get_target_status(port, verbose=False):
 
     trace_enabled = r.group(1) == "1"
     profile_enabled = r.group(2) == "1"
+    dynamic_trigger_enabled = r.group(3) == "1"
 
-    return {"trace": trace_enabled, "profile": profile_enabled}
+    return {
+        "trace": trace_enabled,
+        "profile": profile_enabled,
+        "dynamic_trigger": dynamic_trigger_enabled
+    }
 
 
 def get_trigger_stopper_addr(port):
@@ -373,6 +378,11 @@ def set_trigger_addr(port, addr, verbose=False):
     is returned. If address '0' is given it disables the trigger.
     """
 
+    status = get_target_status(port, args.verbose)
+    if not status['profile']:
+        print(Fore.YELLOW + "Profile is not supported. Please enable it via 'menuconfig'.")
+        sys.exit(1)
+
     port.write(b'trigger ' + b'0x' + bytes(addr, "ascii") + b'\r')
 
     # Check if trigger was set correctly.
@@ -953,9 +963,11 @@ def status(args):
 
     trace_status = "supported" if status["trace"] else "not supported"
     profile_status = "supported" if status["profile"] else "not supported"
+    dynamic_trigger_status = "supported" if status["dynamic_trigger"] else "not supported"
 
     print(f'Trace {trace_status}.')
     print(f'Profile {profile_status}.')
+    print(f'Dynamic trigger configuration {dynamic_trigger_status}.')
 
 
 def trace(args):
@@ -1002,6 +1014,10 @@ def trace(args):
         args.stopper = args.couple
 
     if args.trigger or args.stopper:
+        if not status['dynamic_trigger']:
+            print(Fore.YELLOW + "Dynamic trigger configuration is not supported. Please enable it via 'menuconfig'.")
+            sys.exit(1)
+
         elf_file = get_elf_file(args, args.verbose)
         addr_to_symbol = get_symbols_from_elf(elf_file, args.verbose)
         symbol_to_addr = generate_reverse_symbol_lookup(addr_to_symbol)
diff --git a/subsys/instrumentation/Kconfig b/subsys/instrumentation/Kconfig
index e67f35a7bc1..8b94b0c1db8 100644
--- a/subsys/instrumentation/Kconfig
+++ b/subsys/instrumentation/Kconfig
@@ -6,11 +6,6 @@
 config INSTRUMENTATION
 	bool "Compiler Instrumentation Support"
 	select REBOOT
-	select RETAINED_MEM
-	select RETAINED_MEM_ZEPHYR_RAM
-	select RETAINED_MEM_MUTEX_FORCE_DISABLE
-	select RETENTION
-	select RETENTION_MUTEX_FORCE_DISABLE
 	select UART_INTERRUPT_DRIVEN
 	help
 	  Enable compiler-managed runtime system instrumentation. This requires
@@ -93,16 +88,29 @@ config INSTRUMENTATION_TRIGGER_FUNCTION
 	default "main"
 	help
 	  Sets the trigger function. Instrumentation (tracing and profiling) is
-	  only turned on when the trigger function is called. The trigger
-	  function can be changed at runtime via the 'zaru' CLI tool.
+	  only turned on when the trigger function is called.
 
 config INSTRUMENTATION_STOPPER_FUNCTION
 	string "Default stopper function used to turn off instrumentation"
 	default "main"
 	help
 	  Sets the stopper function. Instrumentation (tracing and profiling) is
-	  only turned off when the trigger function returns. The stopper
-	  function can be changed at runtime via the 'zaru' CLI tool.
+	  only turned off when the stopper function returns.
+
+config INSTRUMENTATION_DYNAMIC_TRIGGER
+	bool "Dynamic trigger/stopper functions configuration"
+	select RETAINED_MEM
+	select RETAINED_MEM_ZEPHYR_RAM
+	select RETAINED_MEM_MUTEX_FORCE_DISABLE
+	select RETENTION
+	select RETENTION_MUTEX_FORCE_DISABLE
+	default y
+	help
+	  Enables configuration of trigger/stopper functions in runtime.
+	  Enabling this option requires configuration of the 'instrumentation_triggers'
+	  retained memory region in the device tree. When enabled, trigger/stopper
+	  functions can be changed at runtime via the 'zaru' CLI tool.
+
 
 config INSTRUMENTATION_EXCLUDE_FUNCTION_LIST
 	string "Exclude function list"
diff --git a/subsys/instrumentation/common/instr_common.c b/subsys/instrumentation/common/instr_common.c
index c1d1ca97973..0dcee4c448d 100644
--- a/subsys/instrumentation/common/instr_common.c
+++ b/subsys/instrumentation/common/instr_common.c
@@ -36,8 +36,10 @@
  *
  */
 
+#if defined(CONFIG_INSTRUMENTATION_DYNAMIC_TRIGGER)
 const struct device *instrumentation_triggers =
 	DEVICE_DT_GET(DT_NODELABEL(instrumentation_triggers));
+#endif
 
 static bool _instr_initialized;
 static bool _instr_enabled;
@@ -46,6 +48,7 @@ static bool _instr_tracing_disabled;
 static bool _instr_profiling_disabled;
 static bool _instr_tracing_supported = IS_ENABLED(CONFIG_INSTRUMENTATION_MODE_CALLGRAPH);
 static bool _instr_profiling_supported = IS_ENABLED(CONFIG_INSTRUMENTATION_MODE_STATISTICAL);
+static bool _instr_dynamic_trigger_supported = IS_ENABLED(CONFIG_INSTRUMENTATION_DYNAMIC_TRIGGER);
 
 #if defined(CONFIG_INSTRUMENTATION_MODE_STATISTICAL)
 /*
@@ -100,6 +103,11 @@ bool instr_profiling_supported(void)
 	return _instr_profiling_supported;
 }
 
+bool instr_dynamic_trigger_supported(void)
+{
+	return _instr_dynamic_trigger_supported;
+}
+
 __no_instrumentation__
 int instr_init(void)
 {
@@ -116,6 +124,7 @@ int instr_init(void)
 	 */
 	_instr_initialized = 1;
 
+#if defined(CONFIG_INSTRUMENTATION_DYNAMIC_TRIGGER)
 	if (retention_is_valid(instrumentation_triggers)) {
 		/* Retained mem is already initialized, load trigger and stopper addresses */
 		retention_read(instrumentation_triggers, 0, (uint8_t *)&trigger_callee,
@@ -131,6 +140,10 @@ int instr_init(void)
 		retention_write(instrumentation_triggers, sizeof(trigger_callee),
 				(const uint8_t *)&stopper_callee, sizeof(stopper_callee));
 	}
+#else
+	trigger_callee = k_trigger_callee;
+	stopper_callee = k_stopper_callee;
+#endif
 
 #if defined(CONFIG_INSTRUMENTATION_MODE_CALLGRAPH)
 	/* Initialize ring buffer */
@@ -246,8 +259,10 @@ void instr_set_trigger_func(void *callee)
 	/* Update trigger_callee before updating retained mem */
 	trigger_callee = callee;
 
+#if defined(CONFIG_INSTRUMENTATION_DYNAMIC_TRIGGER)
 	retention_write(instrumentation_triggers, 0, (const uint8_t *)&trigger_callee,
 			sizeof(trigger_callee));
+#endif
 }
 
 __no_instrumentation__
@@ -256,8 +271,10 @@ void instr_set_stop_func(void *callee)
 	/* Update stopper_callee before updating retained mem */
 	stopper_callee = callee;
 
+#if defined(CONFIG_INSTRUMENTATION_DYNAMIC_TRIGGER)
 	retention_write(instrumentation_triggers, sizeof(trigger_callee),
 			(const uint8_t *)&stopper_callee, sizeof(stopper_callee));
+#endif
 }
 
 __no_instrumentation__
diff --git a/subsys/instrumentation/transport/uart.c b/subsys/instrumentation/transport/uart.c
index 3af7236557c..b1f5bd37c51 100644
--- a/subsys/instrumentation/transport/uart.c
+++ b/subsys/instrumentation/transport/uart.c
@@ -27,7 +27,7 @@ void handle_cmd(char *cmd, uint32_t length)
 	if (strncmp("reboot", cmd, length) == 0) {
 		sys_reboot(SYS_REBOOT_COLD);
 	} else if (strncmp("status", cmd, length) == 0) {
-		printk("%d %d\n", instr_tracing_supported(), instr_profiling_supported());
+		printk("%d %d %d\n", instr_tracing_supported(), instr_profiling_supported(), instr_dynamic_trigger_supported());
 	} else if (strncmp("ping", cmd, length) == 0) {
 		printk("pong\n");
 	} else if (strncmp("dump_trace", cmd, length) == 0) {
-- 
2.48.1

